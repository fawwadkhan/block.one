{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nvar ecurve = require('ecurve');\n\nvar Point = ecurve.Point;\nvar secp256k1 = ecurve.getCurveByName('secp256k1');\n\nvar BigInteger = require('bigi');\n\nvar assert = require('assert');\n\nvar hash = require('./hash');\n\nvar PublicKey = require('./key_public');\n\nvar keyUtils = require('./key_utils');\n\nvar createHash = require('create-hash');\n\nvar promiseAsync = require('./promise-async');\n\nvar G = secp256k1.G;\nvar n = secp256k1.n;\nmodule.exports = PrivateKey;\n/**\n  @typedef {string} wif - https://en.bitcoin.it/wiki/Wallet_import_format\n  @typedef {string} pubkey - EOSKey..\n  @typedef {ecurve.Point} Point\n*/\n\n/**\n  @param {BigInteger} d\n*/\n\nfunction PrivateKey(d) {\n  if (typeof d === 'string') {\n    return PrivateKey.fromString(d);\n  } else if (Buffer.isBuffer(d)) {\n    return PrivateKey.fromBuffer(d);\n  } else if ((typeof d === 'undefined' ? 'undefined' : _typeof(d)) === 'object' && BigInteger.isBigInteger(d.d)) {\n    return PrivateKey(d.d);\n  }\n\n  if (!BigInteger.isBigInteger(d)) {\n    throw new TypeError('Invalid private key');\n  }\n  /** @return {string} private key like PVT_K1_base58privatekey.. */\n\n\n  function toString() {\n    // todo, use PVT_K1_\n    // return 'PVT_K1_' + keyUtils.checkEncode(toBuffer(), 'K1')\n    return toWif();\n  }\n  /**\n      @return  {wif}\n  */\n\n\n  function toWif() {\n    var private_key = toBuffer(); // checksum includes the version\n\n    private_key = Buffer.concat([new Buffer([0x80]), private_key]);\n    return keyUtils.checkEncode(private_key, 'sha256x2');\n  }\n\n  var public_key = void 0;\n  /**\n      @return {Point}\n  */\n\n  function toPublic() {\n    if (public_key) {\n      // cache\n      // S L O W in the browser\n      return public_key;\n    }\n\n    var Q = secp256k1.G.multiply(d);\n    return public_key = PublicKey.fromPoint(Q);\n  }\n\n  function toBuffer() {\n    return d.toBuffer(32);\n  }\n  /**\n    ECIES\n    @arg {string|Object} pubkey wif, PublicKey object\n    @return {Buffer} 64 byte shared secret\n  */\n\n\n  function getSharedSecret(public_key) {\n    public_key = PublicKey(public_key);\n    var KB = public_key.toUncompressed().toBuffer();\n    var KBP = Point.fromAffine(secp256k1, BigInteger.fromBuffer(KB.slice(1, 33)), // x\n    BigInteger.fromBuffer(KB.slice(33, 65)) // y\n    );\n    var r = toBuffer();\n    var P = KBP.multiply(BigInteger.fromBuffer(r));\n    var S = P.affineX.toBuffer({\n      size: 32\n    }); // SHA512 used in ECIES\n\n    return hash.sha512(S);\n  } // /** ECIES TODO unit test\n  //   @arg {string|Object} pubkey wif, PublicKey object\n  //   @return {Buffer} 64 byte shared secret\n  // */\n  // function getSharedSecret(public_key) {\n  //     public_key = PublicKey(public_key).toUncompressed()\n  //     var P = public_key.Q.multiply( d );\n  //     var S = P.affineX.toBuffer({size: 32});\n  //     // ECIES, adds an extra sha512\n  //     return hash.sha512(S);\n  // }\n\n  /**\n    @arg {string} name - child key name.\n    @return {PrivateKey}\n     @example activePrivate = masterPrivate.getChildKey('owner').getChildKey('active')\n    @example activePrivate.getChildKey('mycontract').getChildKey('myperm')\n  */\n\n\n  function getChildKey(name) {\n    // console.error('WARNING: getChildKey untested against eosd'); // no eosd impl yet\n    var index = createHash('sha256').update(toBuffer()).update(name).digest();\n    return PrivateKey(index);\n  }\n\n  function toHex() {\n    return toBuffer().toString('hex');\n  }\n\n  return {\n    d: d,\n    toWif: toWif,\n    toString: toString,\n    toPublic: toPublic,\n    toBuffer: toBuffer,\n    getSharedSecret: getSharedSecret,\n    getChildKey: getChildKey\n  };\n}\n/** @private */\n\n\nfunction parseKey(privateStr) {\n  assert.equal(typeof privateStr === 'undefined' ? 'undefined' : _typeof(privateStr), 'string', 'privateStr');\n  var match = privateStr.match(/^PVT_([A-Za-z0-9]+)_([A-Za-z0-9]+)$/);\n\n  if (match === null) {\n    // legacy WIF - checksum includes the version\n    var versionKey = keyUtils.checkDecode(privateStr, 'sha256x2');\n    var version = versionKey.readUInt8(0);\n    assert.equal(0x80, version, 'Expected version ' + 0x80 + ', instead got ' + version);\n\n    var _privateKey = PrivateKey.fromBuffer(versionKey.slice(1));\n\n    var _keyType = 'K1';\n    var format = 'WIF';\n    return {\n      privateKey: _privateKey,\n      format: format,\n      keyType: _keyType\n    };\n  }\n\n  assert(match.length === 3, 'Expecting private key like: PVT_K1_base58privateKey..');\n\n  var _match = _slicedToArray(match, 3),\n      keyType = _match[1],\n      keyString = _match[2];\n\n  assert.equal(keyType, 'K1', 'K1 private key expected');\n  var privateKey = PrivateKey.fromBuffer(keyUtils.checkDecode(keyString, keyType));\n  return {\n    privateKey: privateKey,\n    format: 'PVT',\n    keyType: keyType\n  };\n}\n\nPrivateKey.fromHex = function (hex) {\n  return PrivateKey.fromBuffer(new Buffer(hex, 'hex'));\n};\n\nPrivateKey.fromBuffer = function (buf) {\n  if (!Buffer.isBuffer(buf)) {\n    throw new Error(\"Expecting parameter to be a Buffer type\");\n  }\n\n  if (buf.length === 33 && buf[32] === 1) {\n    // remove compression flag\n    buf = buf.slice(0, -1);\n  }\n\n  if (32 !== buf.length) {\n    throw new Error('Expecting 32 bytes, instead got ' + buf.length);\n  }\n\n  return PrivateKey(BigInteger.fromBuffer(buf));\n};\n/**\n    @arg {string} seed - any length string.  This is private, the same seed\n    produces the same private key every time.\n\n    @return {PrivateKey}\n*/\n\n\nPrivateKey.fromSeed = function (seed) {\n  // generate_private_key\n  if (!(typeof seed === 'string')) {\n    throw new Error('seed must be of type string');\n  }\n\n  return PrivateKey.fromBuffer(hash.sha256(seed));\n};\n/**\n  @arg {wif} key\n  @return {boolean} true if key is in the Wallet Import Format\n*/\n\n\nPrivateKey.isWif = function (text) {\n  try {\n    assert(parseKey(text).format === 'WIF');\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n/**\n  @arg {wif|Buffer|PrivateKey} key\n  @return {boolean} true if key is convertable to a private key object.\n*/\n\n\nPrivateKey.isValid = function (key) {\n  try {\n    PrivateKey(key);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n/** @deprecated */\n\n\nPrivateKey.fromWif = function (str) {\n  console.log('PrivateKey.fromWif is deprecated, please use PrivateKey.fromString');\n  return PrivateKey.fromString(str);\n};\n/**\n    @throws {AssertError|Error} parsing key\n    @arg {string} privateStr Eosio or Wallet Import Format (wif) -- a secret\n*/\n\n\nPrivateKey.fromString = function (privateStr) {\n  return parseKey(privateStr).privateKey;\n};\n/**\n  Create a new random private key.\n\n  Call initialize() first to run some self-checking code and gather some CPU\n  entropy.\n\n  @arg {number} [cpuEntropyBits = 0] - additional CPU entropy, this already\n  happens once so it should not be needed again.\n\n  @return {Promise<PrivateKey>} - random private key\n*/\n\n\nPrivateKey.randomKey = function () {\n  var cpuEntropyBits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return PrivateKey.initialize().then(function () {\n    return PrivateKey.fromBuffer(keyUtils.random32ByteBuffer({\n      cpuEntropyBits: cpuEntropyBits\n    }));\n  });\n};\n/**\n  @return {Promise<PrivateKey>} for testing, does not require initialize().\n*/\n\n\nPrivateKey.unsafeRandomKey = function () {\n  return Promise.resolve(PrivateKey.fromBuffer(keyUtils.random32ByteBuffer({\n    safe: false\n  })));\n};\n\nvar initialized = false,\n    unitTested = false;\n/**\n  Run self-checking code and gather CPU entropy.\n\n  Initialization happens once even if called multiple times.\n\n  @return {Promise}\n*/\n\nfunction initialize() {\n  if (initialized) {\n    return;\n  }\n\n  unitTest();\n  keyUtils.addEntropy.apply(keyUtils, _toConsumableArray(keyUtils.cpuEntropy()));\n  assert(keyUtils.entropyCount() >= 128, 'insufficient entropy');\n  initialized = true;\n}\n\nPrivateKey.initialize = promiseAsync(initialize);\n/**\n  Unit test basic private and public key functionality.\n\n  @throws {AssertError}\n*/\n\nfunction unitTest() {\n  var pvt = PrivateKey(hash.sha256(''));\n  var pvtError = 'key comparison test failed on a known private key';\n  assert.equal(pvt.toWif(), '5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss', pvtError);\n  assert.equal(pvt.toString(), '5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss', pvtError); // assert.equal(pvt.toString(), 'PVT_K1_2jH3nnhxhR3zPUcsKaWWZC9ZmZAnKm3GAnFD1xynGJE1Znuvjd', pvtError)\n\n  var pub = pvt.toPublic();\n  var pubError = 'pubkey string comparison test failed on a known public key';\n  assert.equal(pub.toString(), 'EOS859gxfnXyUriMgUeThh1fWv3oqcpLFyHa3TfFYC4PK2HqhToVM', pubError); // assert.equal(pub.toString(), 'PUB_K1_859gxfnXyUriMgUeThh1fWv3oqcpLFyHa3TfFYC4PK2Ht7beeX', pubError)\n  // assert.equal(pub.toStringLegacy(), 'EOS859gxfnXyUriMgUeThh1fWv3oqcpLFyHa3TfFYC4PK2HqhToVM', pubError)\n\n  doesNotThrow(function () {\n    return PrivateKey.fromString(pvt.toWif());\n  }, 'converting known wif from string');\n  doesNotThrow(function () {\n    return PrivateKey.fromString(pvt.toString());\n  }, 'converting known pvt from string');\n  doesNotThrow(function () {\n    return PublicKey.fromString(pub.toString());\n  }, 'converting known public key from string'); // doesNotThrow(() => PublicKey.fromString(pub.toStringLegacy()), 'converting known public key from string')\n\n  unitTested = true;\n}\n/** @private */\n\n\nvar doesNotThrow = function doesNotThrow(cb, msg) {\n  try {\n    cb();\n  } catch (error) {\n    error.message = msg + ' ==> ' + error.message;\n    throw error;\n  }\n};","map":{"version":3,"sources":["/Users/madcad/Documents/block.three/node_modules/eosjs-ecc/lib/key_private.js"],"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","Object","TypeError","_typeof","obj","constructor","prototype","_toConsumableArray","arr2","from","ecurve","require","Point","secp256k1","getCurveByName","BigInteger","assert","hash","PublicKey","keyUtils","createHash","promiseAsync","G","n","module","exports","PrivateKey","d","fromString","Buffer","isBuffer","fromBuffer","isBigInteger","toString","toWif","private_key","toBuffer","concat","checkEncode","public_key","toPublic","Q","multiply","fromPoint","getSharedSecret","KB","toUncompressed","KBP","fromAffine","slice","r","P","S","affineX","size","sha512","getChildKey","name","index","update","digest","toHex","parseKey","privateStr","equal","match","versionKey","checkDecode","version","readUInt8","_privateKey","_keyType","format","privateKey","keyType","_match","keyString","fromHex","hex","buf","Error","fromSeed","seed","sha256","isWif","text","e","isValid","key","fromWif","str","console","log","randomKey","cpuEntropyBits","arguments","initialize","then","random32ByteBuffer","unsafeRandomKey","Promise","resolve","safe","initialized","unitTested","unitTest","addEntropy","apply","cpuEntropy","entropyCount","pvt","pvtError","pub","pubError","doesNotThrow","cb","msg","error","message"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar ecurve = require('ecurve');\nvar Point = ecurve.Point;\nvar secp256k1 = ecurve.getCurveByName('secp256k1');\nvar BigInteger = require('bigi');\nvar assert = require('assert');\n\nvar hash = require('./hash');\nvar PublicKey = require('./key_public');\nvar keyUtils = require('./key_utils');\nvar createHash = require('create-hash');\nvar promiseAsync = require('./promise-async');\n\nvar G = secp256k1.G;\nvar n = secp256k1.n;\n\nmodule.exports = PrivateKey;\n\n/**\n  @typedef {string} wif - https://en.bitcoin.it/wiki/Wallet_import_format\n  @typedef {string} pubkey - EOSKey..\n  @typedef {ecurve.Point} Point\n*/\n\n/**\n  @param {BigInteger} d\n*/\nfunction PrivateKey(d) {\n    if (typeof d === 'string') {\n        return PrivateKey.fromString(d);\n    } else if (Buffer.isBuffer(d)) {\n        return PrivateKey.fromBuffer(d);\n    } else if ((typeof d === 'undefined' ? 'undefined' : _typeof(d)) === 'object' && BigInteger.isBigInteger(d.d)) {\n        return PrivateKey(d.d);\n    }\n\n    if (!BigInteger.isBigInteger(d)) {\n        throw new TypeError('Invalid private key');\n    }\n\n    /** @return {string} private key like PVT_K1_base58privatekey.. */\n    function toString() {\n        // todo, use PVT_K1_\n        // return 'PVT_K1_' + keyUtils.checkEncode(toBuffer(), 'K1')\n        return toWif();\n    }\n\n    /**\n        @return  {wif}\n    */\n    function toWif() {\n        var private_key = toBuffer();\n        // checksum includes the version\n        private_key = Buffer.concat([new Buffer([0x80]), private_key]);\n        return keyUtils.checkEncode(private_key, 'sha256x2');\n    }\n\n    var public_key = void 0;\n\n    /**\n        @return {Point}\n    */\n    function toPublic() {\n        if (public_key) {\n            // cache\n            // S L O W in the browser\n            return public_key;\n        }\n        var Q = secp256k1.G.multiply(d);\n        return public_key = PublicKey.fromPoint(Q);\n    }\n\n    function toBuffer() {\n        return d.toBuffer(32);\n    }\n\n    /**\n      ECIES\n      @arg {string|Object} pubkey wif, PublicKey object\n      @return {Buffer} 64 byte shared secret\n    */\n    function getSharedSecret(public_key) {\n        public_key = PublicKey(public_key);\n        var KB = public_key.toUncompressed().toBuffer();\n        var KBP = Point.fromAffine(secp256k1, BigInteger.fromBuffer(KB.slice(1, 33)), // x\n        BigInteger.fromBuffer(KB.slice(33, 65)) // y\n        );\n        var r = toBuffer();\n        var P = KBP.multiply(BigInteger.fromBuffer(r));\n        var S = P.affineX.toBuffer({ size: 32 });\n        // SHA512 used in ECIES\n        return hash.sha512(S);\n    }\n\n    // /** ECIES TODO unit test\n    //   @arg {string|Object} pubkey wif, PublicKey object\n    //   @return {Buffer} 64 byte shared secret\n    // */\n    // function getSharedSecret(public_key) {\n    //     public_key = PublicKey(public_key).toUncompressed()\n    //     var P = public_key.Q.multiply( d );\n    //     var S = P.affineX.toBuffer({size: 32});\n    //     // ECIES, adds an extra sha512\n    //     return hash.sha512(S);\n    // }\n\n    /**\n      @arg {string} name - child key name.\n      @return {PrivateKey}\n       @example activePrivate = masterPrivate.getChildKey('owner').getChildKey('active')\n      @example activePrivate.getChildKey('mycontract').getChildKey('myperm')\n    */\n    function getChildKey(name) {\n        // console.error('WARNING: getChildKey untested against eosd'); // no eosd impl yet\n        var index = createHash('sha256').update(toBuffer()).update(name).digest();\n        return PrivateKey(index);\n    }\n\n    function toHex() {\n        return toBuffer().toString('hex');\n    }\n\n    return {\n        d: d,\n        toWif: toWif,\n        toString: toString,\n        toPublic: toPublic,\n        toBuffer: toBuffer,\n        getSharedSecret: getSharedSecret,\n        getChildKey: getChildKey\n    };\n}\n\n/** @private */\nfunction parseKey(privateStr) {\n    assert.equal(typeof privateStr === 'undefined' ? 'undefined' : _typeof(privateStr), 'string', 'privateStr');\n    var match = privateStr.match(/^PVT_([A-Za-z0-9]+)_([A-Za-z0-9]+)$/);\n\n    if (match === null) {\n        // legacy WIF - checksum includes the version\n        var versionKey = keyUtils.checkDecode(privateStr, 'sha256x2');\n        var version = versionKey.readUInt8(0);\n        assert.equal(0x80, version, 'Expected version ' + 0x80 + ', instead got ' + version);\n        var _privateKey = PrivateKey.fromBuffer(versionKey.slice(1));\n        var _keyType = 'K1';\n        var format = 'WIF';\n        return { privateKey: _privateKey, format: format, keyType: _keyType };\n    }\n\n    assert(match.length === 3, 'Expecting private key like: PVT_K1_base58privateKey..');\n\n    var _match = _slicedToArray(match, 3),\n        keyType = _match[1],\n        keyString = _match[2];\n\n    assert.equal(keyType, 'K1', 'K1 private key expected');\n    var privateKey = PrivateKey.fromBuffer(keyUtils.checkDecode(keyString, keyType));\n    return { privateKey: privateKey, format: 'PVT', keyType: keyType };\n}\n\nPrivateKey.fromHex = function (hex) {\n    return PrivateKey.fromBuffer(new Buffer(hex, 'hex'));\n};\n\nPrivateKey.fromBuffer = function (buf) {\n    if (!Buffer.isBuffer(buf)) {\n        throw new Error(\"Expecting parameter to be a Buffer type\");\n    }\n    if (buf.length === 33 && buf[32] === 1) {\n        // remove compression flag\n        buf = buf.slice(0, -1);\n    }\n    if (32 !== buf.length) {\n        throw new Error('Expecting 32 bytes, instead got ' + buf.length);\n    }\n    return PrivateKey(BigInteger.fromBuffer(buf));\n};\n\n/**\n    @arg {string} seed - any length string.  This is private, the same seed\n    produces the same private key every time.\n\n    @return {PrivateKey}\n*/\nPrivateKey.fromSeed = function (seed) {\n    // generate_private_key\n    if (!(typeof seed === 'string')) {\n        throw new Error('seed must be of type string');\n    }\n    return PrivateKey.fromBuffer(hash.sha256(seed));\n};\n\n/**\n  @arg {wif} key\n  @return {boolean} true if key is in the Wallet Import Format\n*/\nPrivateKey.isWif = function (text) {\n    try {\n        assert(parseKey(text).format === 'WIF');\n        return true;\n    } catch (e) {\n        return false;\n    }\n};\n\n/**\n  @arg {wif|Buffer|PrivateKey} key\n  @return {boolean} true if key is convertable to a private key object.\n*/\nPrivateKey.isValid = function (key) {\n    try {\n        PrivateKey(key);\n        return true;\n    } catch (e) {\n        return false;\n    }\n};\n\n/** @deprecated */\nPrivateKey.fromWif = function (str) {\n    console.log('PrivateKey.fromWif is deprecated, please use PrivateKey.fromString');\n    return PrivateKey.fromString(str);\n};\n\n/**\n    @throws {AssertError|Error} parsing key\n    @arg {string} privateStr Eosio or Wallet Import Format (wif) -- a secret\n*/\nPrivateKey.fromString = function (privateStr) {\n    return parseKey(privateStr).privateKey;\n};\n\n/**\n  Create a new random private key.\n\n  Call initialize() first to run some self-checking code and gather some CPU\n  entropy.\n\n  @arg {number} [cpuEntropyBits = 0] - additional CPU entropy, this already\n  happens once so it should not be needed again.\n\n  @return {Promise<PrivateKey>} - random private key\n*/\nPrivateKey.randomKey = function () {\n    var cpuEntropyBits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    return PrivateKey.initialize().then(function () {\n        return PrivateKey.fromBuffer(keyUtils.random32ByteBuffer({ cpuEntropyBits: cpuEntropyBits }));\n    });\n};\n\n/**\n  @return {Promise<PrivateKey>} for testing, does not require initialize().\n*/\nPrivateKey.unsafeRandomKey = function () {\n    return Promise.resolve(PrivateKey.fromBuffer(keyUtils.random32ByteBuffer({ safe: false })));\n};\n\nvar initialized = false,\n    unitTested = false;\n\n/**\n  Run self-checking code and gather CPU entropy.\n\n  Initialization happens once even if called multiple times.\n\n  @return {Promise}\n*/\nfunction initialize() {\n    if (initialized) {\n        return;\n    }\n\n    unitTest();\n    keyUtils.addEntropy.apply(keyUtils, _toConsumableArray(keyUtils.cpuEntropy()));\n    assert(keyUtils.entropyCount() >= 128, 'insufficient entropy');\n\n    initialized = true;\n}\n\nPrivateKey.initialize = promiseAsync(initialize);\n\n/**\n  Unit test basic private and public key functionality.\n\n  @throws {AssertError}\n*/\nfunction unitTest() {\n    var pvt = PrivateKey(hash.sha256(''));\n\n    var pvtError = 'key comparison test failed on a known private key';\n    assert.equal(pvt.toWif(), '5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss', pvtError);\n    assert.equal(pvt.toString(), '5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss', pvtError);\n    // assert.equal(pvt.toString(), 'PVT_K1_2jH3nnhxhR3zPUcsKaWWZC9ZmZAnKm3GAnFD1xynGJE1Znuvjd', pvtError)\n\n    var pub = pvt.toPublic();\n    var pubError = 'pubkey string comparison test failed on a known public key';\n    assert.equal(pub.toString(), 'EOS859gxfnXyUriMgUeThh1fWv3oqcpLFyHa3TfFYC4PK2HqhToVM', pubError);\n    // assert.equal(pub.toString(), 'PUB_K1_859gxfnXyUriMgUeThh1fWv3oqcpLFyHa3TfFYC4PK2Ht7beeX', pubError)\n    // assert.equal(pub.toStringLegacy(), 'EOS859gxfnXyUriMgUeThh1fWv3oqcpLFyHa3TfFYC4PK2HqhToVM', pubError)\n\n    doesNotThrow(function () {\n        return PrivateKey.fromString(pvt.toWif());\n    }, 'converting known wif from string');\n    doesNotThrow(function () {\n        return PrivateKey.fromString(pvt.toString());\n    }, 'converting known pvt from string');\n    doesNotThrow(function () {\n        return PublicKey.fromString(pub.toString());\n    }, 'converting known public key from string');\n    // doesNotThrow(() => PublicKey.fromString(pub.toStringLegacy()), 'converting known public key from string')\n\n    unitTested = true;\n}\n\n/** @private */\nvar doesNotThrow = function doesNotThrow(cb, msg) {\n    try {\n        cb();\n    } catch (error) {\n        error.message = msg + ' ==> ' + error.message;\n        throw error;\n    }\n};"]},"metadata":{},"sourceType":"script"}