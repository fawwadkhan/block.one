{"ast":null,"code":"'use strict';\n\nvar assert = require('assert'); // from github.com/bitcoinjs/bitcoinjs-lib from github.com/cryptocoinjs/ecdsa\n\n\nvar crypto = require('./hash');\n\nvar enforceType = require('./enforce_types');\n\nvar BigInteger = require('bigi');\n\nvar ECSignature = require('./ecsignature'); // https://tools.ietf.org/html/rfc6979#section-3.2\n\n\nfunction deterministicGenerateK(curve, hash, d, checkSig, nonce) {\n  enforceType('Buffer', hash);\n  enforceType(BigInteger, d);\n\n  if (nonce) {\n    hash = crypto.sha256(Buffer.concat([hash, new Buffer(nonce)]));\n  } // sanity check\n\n\n  assert.equal(hash.length, 32, 'Hash must be 256 bit');\n  var x = d.toBuffer(32);\n  var k = new Buffer(32);\n  var v = new Buffer(32); // Step B\n\n  v.fill(1); // Step C\n\n  k.fill(0); // Step D\n\n  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0]), x, hash]), k); // Step E\n\n  v = crypto.HmacSHA256(v, k); // Step F\n\n  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([1]), x, hash]), k); // Step G\n\n  v = crypto.HmacSHA256(v, k); // Step H1/H2a, ignored as tlen === qlen (256 bit)\n  // Step H2b\n\n  v = crypto.HmacSHA256(v, k);\n  var T = BigInteger.fromBuffer(v); // Step H3, repeat until T is within the interval [1, n - 1]\n\n  while (T.signum() <= 0 || T.compareTo(curve.n) >= 0 || !checkSig(T)) {\n    k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0])]), k);\n    v = crypto.HmacSHA256(v, k); // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n    // Step H2b again\n\n    v = crypto.HmacSHA256(v, k);\n    T = BigInteger.fromBuffer(v);\n  }\n\n  return T;\n}\n\nfunction sign(curve, hash, d, nonce) {\n  var e = BigInteger.fromBuffer(hash);\n  var n = curve.n;\n  var G = curve.G;\n  var r, s;\n  var k = deterministicGenerateK(curve, hash, d, function (k) {\n    // find canonically valid signature\n    var Q = G.multiply(k);\n    if (curve.isInfinity(Q)) return false;\n    r = Q.affineX.mod(n);\n    if (r.signum() === 0) return false;\n    s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);\n    if (s.signum() === 0) return false;\n    return true;\n  }, nonce);\n  var N_OVER_TWO = n.shiftRight(1); // enforce low S values, see bip62: 'low s values in signatures'\n\n  if (s.compareTo(N_OVER_TWO) > 0) {\n    s = n.subtract(s);\n  }\n\n  return ECSignature(r, s);\n}\n\nfunction verifyRaw(curve, e, signature, Q) {\n  var n = curve.n;\n  var G = curve.G;\n  var r = signature.r;\n  var s = signature.s; // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1]\n\n  if (r.signum() <= 0 || r.compareTo(n) >= 0) return false;\n  if (s.signum() <= 0 || s.compareTo(n) >= 0) return false; // c = s^-1 mod n\n\n  var c = s.modInverse(n); // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n\n  var u1 = e.multiply(c).mod(n);\n  var u2 = r.multiply(c).mod(n); // 1.4.5 Compute R = (xR, yR) = u1G + u2Q\n\n  var R = G.multiplyTwo(u1, Q, u2); // 1.4.5 (cont.) Enforce R is not at infinity\n\n  if (curve.isInfinity(R)) return false; // 1.4.6 Convert the field element R.x to an integer\n\n  var xR = R.affineX; // 1.4.7 Set v = xR mod n\n\n  var v = xR.mod(n); // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n\n  return v.equals(r);\n}\n\nfunction verify(curve, hash, signature, Q) {\n  // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n  var e = BigInteger.fromBuffer(hash);\n  return verifyRaw(curve, e, signature, Q);\n}\n/**\n  * Recover a public key from a signature.\n  *\n  * See SEC 1: Elliptic Curve Cryptography, section 4.1.6, \"Public\n  * Key Recovery Operation\".\n  *\n  * http://www.secg.org/download/aid-780/sec1-v2.pdf\n  */\n\n\nfunction recoverPubKey(curve, e, signature, i) {\n  assert.strictEqual(i & 3, i, 'Recovery param is more than two bits');\n  var n = curve.n;\n  var G = curve.G;\n  var r = signature.r;\n  var s = signature.s;\n  assert(r.signum() > 0 && r.compareTo(n) < 0, 'Invalid r value');\n  assert(s.signum() > 0 && s.compareTo(n) < 0, 'Invalid s value'); // A set LSB signifies that the y-coordinate is odd\n\n  var isYOdd = i & 1; // The more significant bit specifies whether we should use the\n  // first or second candidate key.\n\n  var isSecondKey = i >> 1; // 1.1 Let x = r + jn\n\n  var x = isSecondKey ? r.add(n) : r;\n  var R = curve.pointFromX(isYOdd, x); // 1.4 Check that nR is at infinity\n\n  var nR = R.multiply(n);\n  assert(curve.isInfinity(nR), 'nR is not a valid curve point'); // Compute -e from e\n\n  var eNeg = e.negate().mod(n); // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n\n  var rInv = r.modInverse(n);\n  var Q = R.multiplyTwo(s, G, eNeg).multiply(rInv);\n  curve.validate(Q);\n  return Q;\n}\n/**\n  * Calculate pubkey extraction parameter.\n  *\n  * When extracting a pubkey from a signature, we have to\n  * distinguish four different cases. Rather than putting this\n  * burden on the verifier, Bitcoin includes a 2-bit value with the\n  * signature.\n  *\n  * This function simply tries all four cases and returns the value\n  * that resulted in a successful pubkey recovery.\n  */\n\n\nfunction calcPubKeyRecoveryParam(curve, e, signature, Q) {\n  for (var i = 0; i < 4; i++) {\n    var Qprime = recoverPubKey(curve, e, signature, i); // 1.6.2 Verify Q\n\n    if (Qprime.equals(Q)) {\n      return i;\n    }\n  }\n\n  throw new Error('Unable to find valid recovery factor');\n}\n\nmodule.exports = {\n  calcPubKeyRecoveryParam: calcPubKeyRecoveryParam,\n  deterministicGenerateK: deterministicGenerateK,\n  recoverPubKey: recoverPubKey,\n  sign: sign,\n  verify: verify,\n  verifyRaw: verifyRaw\n};","map":{"version":3,"sources":["/Users/madcad/Documents/block.three/node_modules/eosjs-ecc/lib/ecdsa.js"],"names":["assert","require","crypto","enforceType","BigInteger","ECSignature","deterministicGenerateK","curve","hash","d","checkSig","nonce","sha256","Buffer","concat","equal","length","x","toBuffer","k","v","fill","HmacSHA256","T","fromBuffer","signum","compareTo","n","sign","e","G","r","s","Q","multiply","isInfinity","affineX","mod","modInverse","add","N_OVER_TWO","shiftRight","subtract","verifyRaw","signature","c","u1","u2","R","multiplyTwo","xR","equals","verify","recoverPubKey","i","strictEqual","isYOdd","isSecondKey","pointFromX","nR","eNeg","negate","rInv","validate","calcPubKeyRecoveryParam","Qprime","Error","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar assert = require('assert'); // from github.com/bitcoinjs/bitcoinjs-lib from github.com/cryptocoinjs/ecdsa\nvar crypto = require('./hash');\nvar enforceType = require('./enforce_types');\n\nvar BigInteger = require('bigi');\nvar ECSignature = require('./ecsignature');\n\n// https://tools.ietf.org/html/rfc6979#section-3.2\nfunction deterministicGenerateK(curve, hash, d, checkSig, nonce) {\n\n  enforceType('Buffer', hash);\n  enforceType(BigInteger, d);\n\n  if (nonce) {\n    hash = crypto.sha256(Buffer.concat([hash, new Buffer(nonce)]));\n  }\n\n  // sanity check\n  assert.equal(hash.length, 32, 'Hash must be 256 bit');\n\n  var x = d.toBuffer(32);\n  var k = new Buffer(32);\n  var v = new Buffer(32);\n\n  // Step B\n  v.fill(1);\n\n  // Step C\n  k.fill(0);\n\n  // Step D\n  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0]), x, hash]), k);\n\n  // Step E\n  v = crypto.HmacSHA256(v, k);\n\n  // Step F\n  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([1]), x, hash]), k);\n\n  // Step G\n  v = crypto.HmacSHA256(v, k);\n\n  // Step H1/H2a, ignored as tlen === qlen (256 bit)\n  // Step H2b\n  v = crypto.HmacSHA256(v, k);\n\n  var T = BigInteger.fromBuffer(v);\n\n  // Step H3, repeat until T is within the interval [1, n - 1]\n  while (T.signum() <= 0 || T.compareTo(curve.n) >= 0 || !checkSig(T)) {\n    k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0])]), k);\n    v = crypto.HmacSHA256(v, k);\n\n    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n    // Step H2b again\n    v = crypto.HmacSHA256(v, k);\n\n    T = BigInteger.fromBuffer(v);\n  }\n\n  return T;\n}\n\nfunction sign(curve, hash, d, nonce) {\n\n  var e = BigInteger.fromBuffer(hash);\n  var n = curve.n;\n  var G = curve.G;\n\n  var r, s;\n  var k = deterministicGenerateK(curve, hash, d, function (k) {\n    // find canonically valid signature\n    var Q = G.multiply(k);\n\n    if (curve.isInfinity(Q)) return false;\n\n    r = Q.affineX.mod(n);\n    if (r.signum() === 0) return false;\n\n    s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);\n    if (s.signum() === 0) return false;\n\n    return true;\n  }, nonce);\n\n  var N_OVER_TWO = n.shiftRight(1);\n\n  // enforce low S values, see bip62: 'low s values in signatures'\n  if (s.compareTo(N_OVER_TWO) > 0) {\n    s = n.subtract(s);\n  }\n\n  return ECSignature(r, s);\n}\n\nfunction verifyRaw(curve, e, signature, Q) {\n  var n = curve.n;\n  var G = curve.G;\n\n  var r = signature.r;\n  var s = signature.s;\n\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1]\n  if (r.signum() <= 0 || r.compareTo(n) >= 0) return false;\n  if (s.signum() <= 0 || s.compareTo(n) >= 0) return false;\n\n  // c = s^-1 mod n\n  var c = s.modInverse(n);\n\n  // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n  var u1 = e.multiply(c).mod(n);\n  var u2 = r.multiply(c).mod(n);\n\n  // 1.4.5 Compute R = (xR, yR) = u1G + u2Q\n  var R = G.multiplyTwo(u1, Q, u2);\n\n  // 1.4.5 (cont.) Enforce R is not at infinity\n  if (curve.isInfinity(R)) return false;\n\n  // 1.4.6 Convert the field element R.x to an integer\n  var xR = R.affineX;\n\n  // 1.4.7 Set v = xR mod n\n  var v = xR.mod(n);\n\n  // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n  return v.equals(r);\n}\n\nfunction verify(curve, hash, signature, Q) {\n  // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n  var e = BigInteger.fromBuffer(hash);\n  return verifyRaw(curve, e, signature, Q);\n}\n\n/**\n  * Recover a public key from a signature.\n  *\n  * See SEC 1: Elliptic Curve Cryptography, section 4.1.6, \"Public\n  * Key Recovery Operation\".\n  *\n  * http://www.secg.org/download/aid-780/sec1-v2.pdf\n  */\nfunction recoverPubKey(curve, e, signature, i) {\n  assert.strictEqual(i & 3, i, 'Recovery param is more than two bits');\n\n  var n = curve.n;\n  var G = curve.G;\n\n  var r = signature.r;\n  var s = signature.s;\n\n  assert(r.signum() > 0 && r.compareTo(n) < 0, 'Invalid r value');\n  assert(s.signum() > 0 && s.compareTo(n) < 0, 'Invalid s value');\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = i & 1;\n\n  // The more significant bit specifies whether we should use the\n  // first or second candidate key.\n  var isSecondKey = i >> 1;\n\n  // 1.1 Let x = r + jn\n  var x = isSecondKey ? r.add(n) : r;\n  var R = curve.pointFromX(isYOdd, x);\n\n  // 1.4 Check that nR is at infinity\n  var nR = R.multiply(n);\n  assert(curve.isInfinity(nR), 'nR is not a valid curve point');\n\n  // Compute -e from e\n  var eNeg = e.negate().mod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  var rInv = r.modInverse(n);\n\n  var Q = R.multiplyTwo(s, G, eNeg).multiply(rInv);\n  curve.validate(Q);\n\n  return Q;\n}\n\n/**\n  * Calculate pubkey extraction parameter.\n  *\n  * When extracting a pubkey from a signature, we have to\n  * distinguish four different cases. Rather than putting this\n  * burden on the verifier, Bitcoin includes a 2-bit value with the\n  * signature.\n  *\n  * This function simply tries all four cases and returns the value\n  * that resulted in a successful pubkey recovery.\n  */\nfunction calcPubKeyRecoveryParam(curve, e, signature, Q) {\n  for (var i = 0; i < 4; i++) {\n    var Qprime = recoverPubKey(curve, e, signature, i);\n\n    // 1.6.2 Verify Q\n    if (Qprime.equals(Q)) {\n      return i;\n    }\n  }\n\n  throw new Error('Unable to find valid recovery factor');\n}\n\nmodule.exports = {\n  calcPubKeyRecoveryParam: calcPubKeyRecoveryParam,\n  deterministicGenerateK: deterministicGenerateK,\n  recoverPubKey: recoverPubKey,\n  sign: sign,\n  verify: verify,\n  verifyRaw: verifyRaw\n};"]},"metadata":{},"sourceType":"script"}