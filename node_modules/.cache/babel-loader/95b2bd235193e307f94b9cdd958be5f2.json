{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar assert = require('assert');\n\nvar ecurve = require('ecurve');\n\nvar BigInteger = require('bigi');\n\nvar secp256k1 = ecurve.getCurveByName('secp256k1');\n\nvar hash = require('./hash');\n\nvar keyUtils = require('./key_utils');\n\nvar G = secp256k1.G;\nvar n = secp256k1.n;\nmodule.exports = PublicKey;\n/**\n  @param {string|Buffer|PublicKey|ecurve.Point} public key\n  @param {string} [pubkey_prefix = 'EOS']\n*/\n\nfunction PublicKey(Q) {\n  var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n\n  if (typeof Q === 'string') {\n    var publicKey = PublicKey.fromString(Q, pubkey_prefix);\n    assert(publicKey != null, 'Invalid public key');\n    return publicKey;\n  } else if (Buffer.isBuffer(Q)) {\n    return PublicKey.fromBuffer(Q);\n  } else if ((typeof Q === 'undefined' ? 'undefined' : _typeof(Q)) === 'object' && Q.Q) {\n    return PublicKey(Q.Q);\n  }\n\n  assert.equal(typeof Q === 'undefined' ? 'undefined' : _typeof(Q), 'object', 'Invalid public key');\n  assert.equal(_typeof(Q.compressed), 'boolean', 'Invalid public key');\n\n  function toBuffer() {\n    var compressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Q.compressed;\n    return Q.getEncoded(compressed);\n  }\n\n  var pubdata = void 0; // cache\n  // /**\n  //     @todo secp224r1\n  //     @return {string} PUB_K1_base58pubkey..\n  // */\n  // function toString() {\n  //     if(pubdata) {\n  //         return pubdata\n  //     }\n  //     pubdata = `PUB_K1_` + keyUtils.checkEncode(toBuffer(), 'K1')\n  //     return pubdata;\n  // }\n\n  /** @todo rename to toStringLegacy\n   * @arg {string} [pubkey_prefix = 'EOS'] - public key prefix\n  */\n\n  function toString() {\n    var pubkey_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'EOS';\n    return pubkey_prefix + keyUtils.checkEncode(toBuffer());\n  }\n\n  function toUncompressed() {\n    var buf = Q.getEncoded(false);\n    var point = ecurve.Point.decodeFrom(secp256k1, buf);\n    return PublicKey.fromPoint(point);\n  }\n  /** @deprecated */\n\n\n  function child(offset) {\n    console.error('Deprecated warning: PublicKey.child');\n    assert(Buffer.isBuffer(offset), \"Buffer required: offset\");\n    assert.equal(offset.length, 32, \"offset length\");\n    offset = Buffer.concat([toBuffer(), offset]);\n    offset = hash.sha256(offset);\n    var c = BigInteger.fromBuffer(offset);\n    if (c.compareTo(n) >= 0) throw new Error(\"Child offset went out of bounds, try again\");\n    var cG = G.multiply(c);\n    var Qprime = Q.add(cG);\n    if (secp256k1.isInfinity(Qprime)) throw new Error(\"Child offset derived to an invalid key, try again\");\n    return PublicKey.fromPoint(Qprime);\n  }\n\n  function toHex() {\n    return toBuffer().toString('hex');\n  }\n\n  return {\n    Q: Q,\n    toString: toString,\n    // toStringLegacy,\n    toUncompressed: toUncompressed,\n    toBuffer: toBuffer,\n    child: child,\n    toHex: toHex\n  };\n}\n/**\n  @param {string|Buffer|PublicKey|ecurve.Point} pubkey - public key\n  @param {string} [pubkey_prefix = 'EOS']\n*/\n\n\nPublicKey.isValid = function (pubkey) {\n  var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n\n  try {\n    PublicKey(pubkey, pubkey_prefix);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nPublicKey.fromBinary = function (bin) {\n  return PublicKey.fromBuffer(new Buffer(bin, 'binary'));\n};\n\nPublicKey.fromBuffer = function (buffer) {\n  return PublicKey(ecurve.Point.decodeFrom(secp256k1, buffer));\n};\n\nPublicKey.fromPoint = function (point) {\n  return PublicKey(point);\n};\n/**\n    @arg {string} public_key - like PUB_K1_base58pubkey..\n    @arg {string} [pubkey_prefix = 'EOS'] - public key prefix\n    @return PublicKey or `null` (invalid)\n*/\n\n\nPublicKey.fromString = function (public_key) {\n  var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n\n  try {\n    return PublicKey.fromStringOrThrow(public_key, pubkey_prefix);\n  } catch (e) {\n    return null;\n  }\n};\n/**\n    @arg {string} public_key - like PUB_K1_base58pubkey..\n    @arg {string} [pubkey_prefix = 'EOS'] - public key prefix\n\n    @throws {Error} if public key is invalid\n\n    @return PublicKey\n*/\n\n\nPublicKey.fromStringOrThrow = function (public_key) {\n  var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n  assert.equal(typeof public_key === 'undefined' ? 'undefined' : _typeof(public_key), 'string', 'public_key');\n  var match = public_key.match(/^PUB_([A-Za-z0-9]+)_([A-Za-z0-9]+)$/);\n\n  if (match === null) {\n    // legacy\n    var prefix_match = new RegExp(\"^\" + pubkey_prefix);\n\n    if (prefix_match.test(public_key)) {\n      public_key = public_key.substring(pubkey_prefix.length);\n    }\n\n    return PublicKey.fromBuffer(keyUtils.checkDecode(public_key));\n  }\n\n  assert(match.length === 3, 'Expecting public key like: PUB_K1_base58pubkey..');\n\n  var _match = _slicedToArray(match, 3),\n      keyType = _match[1],\n      keyString = _match[2];\n\n  assert.equal(keyType, 'K1', 'K1 private key expected');\n  return PublicKey.fromBuffer(keyUtils.checkDecode(keyString, keyType));\n};\n\nPublicKey.fromHex = function (hex) {\n  return PublicKey.fromBuffer(new Buffer(hex, 'hex'));\n};\n\nPublicKey.fromStringHex = function (hex) {\n  return PublicKey.fromString(new Buffer(hex, 'hex'));\n};","map":{"version":3,"sources":["/Users/madcad/Documents/block.three/node_modules/eosjs-ecc/lib/key_public.js"],"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","Object","TypeError","_typeof","obj","constructor","prototype","assert","require","ecurve","BigInteger","secp256k1","getCurveByName","hash","keyUtils","G","n","module","exports","PublicKey","Q","pubkey_prefix","arguments","publicKey","fromString","Buffer","isBuffer","fromBuffer","equal","compressed","toBuffer","getEncoded","pubdata","toString","checkEncode","toUncompressed","buf","point","Point","decodeFrom","fromPoint","child","offset","console","error","concat","sha256","c","compareTo","Error","cG","multiply","Qprime","add","isInfinity","toHex","isValid","pubkey","e","fromBinary","bin","buffer","public_key","fromStringOrThrow","match","prefix_match","RegExp","test","substring","checkDecode","_match","keyType","keyString","fromHex","hex","fromStringHex"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar assert = require('assert');\nvar ecurve = require('ecurve');\nvar BigInteger = require('bigi');\nvar secp256k1 = ecurve.getCurveByName('secp256k1');\n\nvar hash = require('./hash');\nvar keyUtils = require('./key_utils');\n\nvar G = secp256k1.G;\nvar n = secp256k1.n;\n\nmodule.exports = PublicKey;\n\n/**\n  @param {string|Buffer|PublicKey|ecurve.Point} public key\n  @param {string} [pubkey_prefix = 'EOS']\n*/\nfunction PublicKey(Q) {\n    var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n\n    if (typeof Q === 'string') {\n        var publicKey = PublicKey.fromString(Q, pubkey_prefix);\n        assert(publicKey != null, 'Invalid public key');\n        return publicKey;\n    } else if (Buffer.isBuffer(Q)) {\n        return PublicKey.fromBuffer(Q);\n    } else if ((typeof Q === 'undefined' ? 'undefined' : _typeof(Q)) === 'object' && Q.Q) {\n        return PublicKey(Q.Q);\n    }\n\n    assert.equal(typeof Q === 'undefined' ? 'undefined' : _typeof(Q), 'object', 'Invalid public key');\n    assert.equal(_typeof(Q.compressed), 'boolean', 'Invalid public key');\n\n    function toBuffer() {\n        var compressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Q.compressed;\n\n        return Q.getEncoded(compressed);\n    }\n\n    var pubdata = void 0; // cache\n\n    // /**\n    //     @todo secp224r1\n    //     @return {string} PUB_K1_base58pubkey..\n    // */\n    // function toString() {\n    //     if(pubdata) {\n    //         return pubdata\n    //     }\n    //     pubdata = `PUB_K1_` + keyUtils.checkEncode(toBuffer(), 'K1')\n    //     return pubdata;\n    // }\n\n    /** @todo rename to toStringLegacy\n     * @arg {string} [pubkey_prefix = 'EOS'] - public key prefix\n    */\n    function toString() {\n        var pubkey_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'EOS';\n\n        return pubkey_prefix + keyUtils.checkEncode(toBuffer());\n    }\n\n    function toUncompressed() {\n        var buf = Q.getEncoded(false);\n        var point = ecurve.Point.decodeFrom(secp256k1, buf);\n        return PublicKey.fromPoint(point);\n    }\n\n    /** @deprecated */\n    function child(offset) {\n        console.error('Deprecated warning: PublicKey.child');\n\n        assert(Buffer.isBuffer(offset), \"Buffer required: offset\");\n        assert.equal(offset.length, 32, \"offset length\");\n\n        offset = Buffer.concat([toBuffer(), offset]);\n        offset = hash.sha256(offset);\n\n        var c = BigInteger.fromBuffer(offset);\n\n        if (c.compareTo(n) >= 0) throw new Error(\"Child offset went out of bounds, try again\");\n\n        var cG = G.multiply(c);\n        var Qprime = Q.add(cG);\n\n        if (secp256k1.isInfinity(Qprime)) throw new Error(\"Child offset derived to an invalid key, try again\");\n\n        return PublicKey.fromPoint(Qprime);\n    }\n\n    function toHex() {\n        return toBuffer().toString('hex');\n    }\n\n    return {\n        Q: Q,\n        toString: toString,\n        // toStringLegacy,\n        toUncompressed: toUncompressed,\n        toBuffer: toBuffer,\n        child: child,\n        toHex: toHex\n    };\n}\n\n/**\n  @param {string|Buffer|PublicKey|ecurve.Point} pubkey - public key\n  @param {string} [pubkey_prefix = 'EOS']\n*/\nPublicKey.isValid = function (pubkey) {\n    var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n\n    try {\n        PublicKey(pubkey, pubkey_prefix);\n        return true;\n    } catch (e) {\n        return false;\n    }\n};\n\nPublicKey.fromBinary = function (bin) {\n    return PublicKey.fromBuffer(new Buffer(bin, 'binary'));\n};\n\nPublicKey.fromBuffer = function (buffer) {\n    return PublicKey(ecurve.Point.decodeFrom(secp256k1, buffer));\n};\n\nPublicKey.fromPoint = function (point) {\n    return PublicKey(point);\n};\n\n/**\n    @arg {string} public_key - like PUB_K1_base58pubkey..\n    @arg {string} [pubkey_prefix = 'EOS'] - public key prefix\n    @return PublicKey or `null` (invalid)\n*/\nPublicKey.fromString = function (public_key) {\n    var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n\n    try {\n        return PublicKey.fromStringOrThrow(public_key, pubkey_prefix);\n    } catch (e) {\n        return null;\n    }\n};\n\n/**\n    @arg {string} public_key - like PUB_K1_base58pubkey..\n    @arg {string} [pubkey_prefix = 'EOS'] - public key prefix\n\n    @throws {Error} if public key is invalid\n\n    @return PublicKey\n*/\nPublicKey.fromStringOrThrow = function (public_key) {\n    var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n\n    assert.equal(typeof public_key === 'undefined' ? 'undefined' : _typeof(public_key), 'string', 'public_key');\n    var match = public_key.match(/^PUB_([A-Za-z0-9]+)_([A-Za-z0-9]+)$/);\n    if (match === null) {\n        // legacy\n        var prefix_match = new RegExp(\"^\" + pubkey_prefix);\n        if (prefix_match.test(public_key)) {\n            public_key = public_key.substring(pubkey_prefix.length);\n        }\n        return PublicKey.fromBuffer(keyUtils.checkDecode(public_key));\n    }\n    assert(match.length === 3, 'Expecting public key like: PUB_K1_base58pubkey..');\n\n    var _match = _slicedToArray(match, 3),\n        keyType = _match[1],\n        keyString = _match[2];\n\n    assert.equal(keyType, 'K1', 'K1 private key expected');\n    return PublicKey.fromBuffer(keyUtils.checkDecode(keyString, keyType));\n};\n\nPublicKey.fromHex = function (hex) {\n    return PublicKey.fromBuffer(new Buffer(hex, 'hex'));\n};\n\nPublicKey.fromStringHex = function (hex) {\n    return PublicKey.fromString(new Buffer(hex, 'hex'));\n};"]},"metadata":{},"sourceType":"script"}