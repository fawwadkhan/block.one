{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar ecdsa = require('./ecdsa');\n\nvar hash = require('./hash');\n\nvar curve = require('ecurve').getCurveByName('secp256k1');\n\nvar assert = require('assert');\n\nvar BigInteger = require('bigi');\n\nvar keyUtils = require('./key_utils');\n\nvar PublicKey = require('./key_public');\n\nvar PrivateKey = require('./key_private');\n\nmodule.exports = Signature;\n\nfunction Signature(r, s, i) {\n  assert.equal(r != null, true, 'Missing parameter');\n  assert.equal(s != null, true, 'Missing parameter');\n  assert.equal(i != null, true, 'Missing parameter');\n  /**\n      Verify signed data.\n       @arg {String|Buffer} data - full data\n      @arg {pubkey|PublicKey} pubkey - EOSKey..\n      @arg {String} [encoding = 'utf8'] - data encoding (if data is a string)\n       @return {boolean}\n  */\n\n  function verify(data, pubkey) {\n    var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf8';\n\n    if (typeof data === 'string') {\n      data = Buffer.from(data, encoding);\n    }\n\n    assert(Buffer.isBuffer(data), 'data is a required String or Buffer');\n    data = hash.sha256(data);\n    return verifyHash(data, pubkey);\n  }\n  /**\n      Verify a buffer of exactally 32 bytes in size (sha256(text))\n       @arg {String|Buffer} dataSha256 - 32 byte buffer or string\n      @arg {String|PublicKey} pubkey - EOSKey..\n      @arg {String} [encoding = 'hex'] - dataSha256 encoding (if string)\n       @return {boolean}\n  */\n\n\n  function verifyHash(dataSha256, pubkey) {\n    var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'hex';\n\n    if (typeof dataSha256 === 'string') {\n      dataSha256 = Buffer.from(dataSha256, encoding);\n    }\n\n    if (dataSha256.length !== 32 || !Buffer.isBuffer(dataSha256)) throw new Error(\"dataSha256: 32 bytes required\");\n    var publicKey = PublicKey(pubkey);\n    assert(publicKey, 'pubkey required');\n    return ecdsa.verify(curve, dataSha256, {\n      r: r,\n      s: s\n    }, publicKey.Q);\n  }\n\n  ;\n  /** @deprecated\n       Verify hex data by converting to a buffer then hashing.\n       @return {boolean}\n  */\n\n  function verifyHex(hex, pubkey) {\n    console.log('Deprecated: use verify(data, pubkey, \"hex\")');\n    var buf = Buffer.from(hex, 'hex');\n    return verify(buf, pubkey);\n  }\n\n  ;\n  /**\n      Recover the public key used to create this signature using full data.\n       @arg {String|Buffer} data - full data\n      @arg {String} [encoding = 'utf8'] - data encoding (if string)\n       @return {PublicKey}\n  */\n\n  function recover(data) {\n    var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'utf8';\n\n    if (typeof data === 'string') {\n      data = Buffer.from(data, encoding);\n    }\n\n    assert(Buffer.isBuffer(data), 'data is a required String or Buffer');\n    data = hash.sha256(data);\n    return recoverHash(data);\n  }\n\n  ;\n  /**\n      @arg {String|Buffer} dataSha256 - sha256 hash 32 byte buffer or hex string\n      @arg {String} [encoding = 'hex'] - dataSha256 encoding (if string)\n       @return {PublicKey}\n  */\n\n  function recoverHash(dataSha256) {\n    var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hex';\n\n    if (typeof dataSha256 === 'string') {\n      dataSha256 = Buffer.from(dataSha256, encoding);\n    }\n\n    if (dataSha256.length !== 32 || !Buffer.isBuffer(dataSha256)) {\n      throw new Error(\"dataSha256: 32 byte String or buffer requred\");\n    }\n\n    var e = BigInteger.fromBuffer(dataSha256);\n    var i2 = i;\n    i2 -= 27;\n    i2 = i2 & 3;\n    var Q = ecdsa.recoverPubKey(curve, e, {\n      r: r,\n      s: s,\n      i: i\n    }, i2);\n    return PublicKey.fromPoint(Q);\n  }\n\n  ;\n\n  function toBuffer() {\n    var buf;\n    buf = new Buffer(65);\n    buf.writeUInt8(i, 0);\n    r.toBuffer(32).copy(buf, 1);\n    s.toBuffer(32).copy(buf, 33);\n    return buf;\n  }\n\n  ;\n\n  function toHex() {\n    return toBuffer().toString(\"hex\");\n  }\n\n  ;\n  var signatureCache = void 0;\n\n  function toString() {\n    if (signatureCache) {\n      return signatureCache;\n    }\n\n    signatureCache = 'SIG_K1_' + keyUtils.checkEncode(toBuffer(), 'K1');\n    return signatureCache;\n  }\n\n  return {\n    r: r,\n    s: s,\n    i: i,\n    toBuffer: toBuffer,\n    verify: verify,\n    verifyHash: verifyHash,\n    verifyHex: verifyHex,\n    // deprecated\n    recover: recover,\n    recoverHash: recoverHash,\n    toHex: toHex,\n    toString: toString,\n\n    /** @deprecated use verify (same arguments and return) */\n    verifyBuffer: function verifyBuffer() {\n      console.log('Deprecated: use signature.verify instead (same arguments)');\n      return verify.apply(undefined, arguments);\n    },\n\n    /** @deprecated use recover (same arguments and return) */\n    recoverPublicKey: function recoverPublicKey() {\n      console.log('Deprecated: use signature.recover instead (same arguments)');\n      return recover.apply(undefined, arguments);\n    },\n\n    /** @deprecated use recoverHash (same arguments and return) */\n    recoverPublicKeyFromBuffer: function recoverPublicKeyFromBuffer() {\n      console.log('Deprecated: use signature.recoverHash instead (same arguments)');\n      return recoverHash.apply(undefined, arguments);\n    }\n  };\n}\n/**\n    Hash and sign arbitrary data.\n\n    @arg {string|Buffer} data - full data\n    @arg {wif|PrivateKey} privateKey\n    @arg {String} [encoding = 'utf8'] - data encoding (if string)\n\n    @return {Signature}\n*/\n\n\nSignature.sign = function (data, privateKey) {\n  var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf8';\n\n  if (typeof data === 'string') {\n    data = Buffer.from(data, encoding);\n  }\n\n  assert(Buffer.isBuffer(data), 'data is a required String or Buffer');\n  data = hash.sha256(data);\n  return Signature.signHash(data, privateKey);\n};\n/**\n    Sign a buffer of exactally 32 bytes in size (sha256(text))\n\n    @arg {string|Buffer} dataSha256 - 32 byte buffer or string\n    @arg {wif|PrivateKey} privateKey\n    @arg {String} [encoding = 'hex'] - dataSha256 encoding (if string)\n\n    @return {Signature}\n*/\n\n\nSignature.signHash = function (dataSha256, privateKey) {\n  var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'hex';\n\n  if (typeof dataSha256 === 'string') {\n    dataSha256 = Buffer.from(dataSha256, encoding);\n  }\n\n  if (dataSha256.length !== 32 || !Buffer.isBuffer(dataSha256)) throw new Error(\"dataSha256: 32 byte buffer requred\");\n  privateKey = PrivateKey(privateKey);\n  assert(privateKey, 'privateKey required');\n  var der, e, ecsignature, i, lenR, lenS, nonce;\n  i = null;\n  nonce = 0;\n  e = BigInteger.fromBuffer(dataSha256);\n\n  while (true) {\n    ecsignature = ecdsa.sign(curve, dataSha256, privateKey.d, nonce++);\n    der = ecsignature.toDER();\n    lenR = der[3];\n    lenS = der[5 + lenR];\n\n    if (lenR === 32 && lenS === 32) {\n      i = ecdsa.calcPubKeyRecoveryParam(curve, e, ecsignature, privateKey.toPublic().Q);\n      i += 4; // compressed\n\n      i += 27; // compact  //  24 or 27 :( forcing odd-y 2nd key candidate)\n\n      break;\n    }\n\n    if (nonce % 10 === 0) {\n      console.log(\"WARN: \" + nonce + \" attempts to find canonical signature\");\n    }\n  }\n\n  return Signature(ecsignature.r, ecsignature.s, i);\n};\n\nSignature.fromBuffer = function (buf) {\n  var i, r, s;\n  assert(Buffer.isBuffer(buf), 'Buffer is required');\n  assert.equal(buf.length, 65, 'Invalid signature length');\n  i = buf.readUInt8(0);\n  assert.equal(i - 27, i - 27 & 7, 'Invalid signature parameter');\n  r = BigInteger.fromBuffer(buf.slice(1, 33));\n  s = BigInteger.fromBuffer(buf.slice(33));\n  return Signature(r, s, i);\n};\n\nSignature.fromHex = function (hex) {\n  return Signature.fromBuffer(Buffer.from(hex, \"hex\"));\n};\n/**\n    @arg {string} signature - like SIG_K1_base58signature..\n    @return {Signature} or `null` (invalid)\n*/\n\n\nSignature.fromString = function (signature) {\n  try {\n    return Signature.fromStringOrThrow(signature);\n  } catch (e) {\n    return null;\n  }\n};\n/**\n    @arg {string} signature - like SIG_K1_base58signature..\n    @throws {Error} invalid\n    @return {Signature}\n*/\n\n\nSignature.fromStringOrThrow = function (signature) {\n  assert.equal(typeof signature === 'undefined' ? 'undefined' : _typeof(signature), 'string', 'signature');\n  var match = signature.match(/^SIG_([A-Za-z0-9]+)_([A-Za-z0-9]+)$/);\n  assert(match != null && match.length === 3, 'Expecting signature like: SIG_K1_base58signature..');\n\n  var _match = _slicedToArray(match, 3),\n      keyType = _match[1],\n      keyString = _match[2];\n\n  assert.equal(keyType, 'K1', 'K1 signature expected');\n  return Signature.fromBuffer(keyUtils.checkDecode(keyString, keyType));\n};\n/**\n    @arg {String|Signature} o - hex string\n    @return {Signature}\n*/\n\n\nSignature.from = function (o) {\n  var signature = o ? o.r && o.s && o.i ? o : typeof o === 'string' && o.length === 130 ? Signature.fromHex(o) : typeof o === 'string' && o.length !== 130 ? Signature.fromStringOrThrow(o) : Buffer.isBuffer(o) ? Signature.fromBuffer(o) : null : o;\n  /*null or undefined*/\n\n  if (!signature) {\n    throw new TypeError('signature should be a hex string or buffer');\n  }\n\n  return signature;\n};","map":{"version":3,"sources":["/Users/madcad/Documents/block.three/node_modules/eosjs-ecc/lib/signature.js"],"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","Object","TypeError","_typeof","obj","constructor","prototype","ecdsa","require","hash","curve","getCurveByName","assert","BigInteger","keyUtils","PublicKey","PrivateKey","module","exports","Signature","r","s","equal","verify","data","pubkey","encoding","arguments","Buffer","from","isBuffer","sha256","verifyHash","dataSha256","Error","publicKey","Q","verifyHex","hex","console","log","buf","recover","recoverHash","e","fromBuffer","i2","recoverPubKey","fromPoint","toBuffer","writeUInt8","copy","toHex","toString","signatureCache","checkEncode","verifyBuffer","apply","recoverPublicKey","recoverPublicKeyFromBuffer","sign","privateKey","signHash","der","ecsignature","lenR","lenS","nonce","d","toDER","calcPubKeyRecoveryParam","toPublic","readUInt8","slice","fromHex","fromString","signature","fromStringOrThrow","match","_match","keyType","keyString","checkDecode","o"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar ecdsa = require('./ecdsa');\nvar hash = require('./hash');\nvar curve = require('ecurve').getCurveByName('secp256k1');\nvar assert = require('assert');\nvar BigInteger = require('bigi');\nvar keyUtils = require('./key_utils');\nvar PublicKey = require('./key_public');\nvar PrivateKey = require('./key_private');\n\nmodule.exports = Signature;\n\nfunction Signature(r, s, i) {\n    assert.equal(r != null, true, 'Missing parameter');\n    assert.equal(s != null, true, 'Missing parameter');\n    assert.equal(i != null, true, 'Missing parameter');\n\n    /**\n        Verify signed data.\n         @arg {String|Buffer} data - full data\n        @arg {pubkey|PublicKey} pubkey - EOSKey..\n        @arg {String} [encoding = 'utf8'] - data encoding (if data is a string)\n         @return {boolean}\n    */\n    function verify(data, pubkey) {\n        var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf8';\n\n        if (typeof data === 'string') {\n            data = Buffer.from(data, encoding);\n        }\n        assert(Buffer.isBuffer(data), 'data is a required String or Buffer');\n        data = hash.sha256(data);\n        return verifyHash(data, pubkey);\n    }\n\n    /**\n        Verify a buffer of exactally 32 bytes in size (sha256(text))\n         @arg {String|Buffer} dataSha256 - 32 byte buffer or string\n        @arg {String|PublicKey} pubkey - EOSKey..\n        @arg {String} [encoding = 'hex'] - dataSha256 encoding (if string)\n         @return {boolean}\n    */\n    function verifyHash(dataSha256, pubkey) {\n        var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'hex';\n\n        if (typeof dataSha256 === 'string') {\n            dataSha256 = Buffer.from(dataSha256, encoding);\n        }\n        if (dataSha256.length !== 32 || !Buffer.isBuffer(dataSha256)) throw new Error(\"dataSha256: 32 bytes required\");\n\n        var publicKey = PublicKey(pubkey);\n        assert(publicKey, 'pubkey required');\n\n        return ecdsa.verify(curve, dataSha256, { r: r, s: s }, publicKey.Q);\n    };\n\n    /** @deprecated\n         Verify hex data by converting to a buffer then hashing.\n         @return {boolean}\n    */\n    function verifyHex(hex, pubkey) {\n        console.log('Deprecated: use verify(data, pubkey, \"hex\")');\n\n        var buf = Buffer.from(hex, 'hex');\n        return verify(buf, pubkey);\n    };\n\n    /**\n        Recover the public key used to create this signature using full data.\n         @arg {String|Buffer} data - full data\n        @arg {String} [encoding = 'utf8'] - data encoding (if string)\n         @return {PublicKey}\n    */\n    function recover(data) {\n        var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'utf8';\n\n        if (typeof data === 'string') {\n            data = Buffer.from(data, encoding);\n        }\n        assert(Buffer.isBuffer(data), 'data is a required String or Buffer');\n        data = hash.sha256(data);\n\n        return recoverHash(data);\n    };\n\n    /**\n        @arg {String|Buffer} dataSha256 - sha256 hash 32 byte buffer or hex string\n        @arg {String} [encoding = 'hex'] - dataSha256 encoding (if string)\n         @return {PublicKey}\n    */\n    function recoverHash(dataSha256) {\n        var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hex';\n\n        if (typeof dataSha256 === 'string') {\n            dataSha256 = Buffer.from(dataSha256, encoding);\n        }\n        if (dataSha256.length !== 32 || !Buffer.isBuffer(dataSha256)) {\n            throw new Error(\"dataSha256: 32 byte String or buffer requred\");\n        }\n\n        var e = BigInteger.fromBuffer(dataSha256);\n        var i2 = i;\n        i2 -= 27;\n        i2 = i2 & 3;\n        var Q = ecdsa.recoverPubKey(curve, e, { r: r, s: s, i: i }, i2);\n        return PublicKey.fromPoint(Q);\n    };\n\n    function toBuffer() {\n        var buf;\n        buf = new Buffer(65);\n        buf.writeUInt8(i, 0);\n        r.toBuffer(32).copy(buf, 1);\n        s.toBuffer(32).copy(buf, 33);\n        return buf;\n    };\n\n    function toHex() {\n        return toBuffer().toString(\"hex\");\n    };\n\n    var signatureCache = void 0;\n\n    function toString() {\n        if (signatureCache) {\n            return signatureCache;\n        }\n        signatureCache = 'SIG_K1_' + keyUtils.checkEncode(toBuffer(), 'K1');\n        return signatureCache;\n    }\n\n    return {\n        r: r, s: s, i: i,\n        toBuffer: toBuffer,\n        verify: verify,\n        verifyHash: verifyHash,\n        verifyHex: verifyHex, // deprecated\n        recover: recover,\n        recoverHash: recoverHash,\n        toHex: toHex,\n        toString: toString,\n\n        /** @deprecated use verify (same arguments and return) */\n        verifyBuffer: function verifyBuffer() {\n            console.log('Deprecated: use signature.verify instead (same arguments)');\n            return verify.apply(undefined, arguments);\n        },\n\n        /** @deprecated use recover (same arguments and return) */\n        recoverPublicKey: function recoverPublicKey() {\n            console.log('Deprecated: use signature.recover instead (same arguments)');\n            return recover.apply(undefined, arguments);\n        },\n\n        /** @deprecated use recoverHash (same arguments and return) */\n        recoverPublicKeyFromBuffer: function recoverPublicKeyFromBuffer() {\n            console.log('Deprecated: use signature.recoverHash instead (same arguments)');\n            return recoverHash.apply(undefined, arguments);\n        }\n    };\n}\n\n/**\n    Hash and sign arbitrary data.\n\n    @arg {string|Buffer} data - full data\n    @arg {wif|PrivateKey} privateKey\n    @arg {String} [encoding = 'utf8'] - data encoding (if string)\n\n    @return {Signature}\n*/\nSignature.sign = function (data, privateKey) {\n    var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf8';\n\n    if (typeof data === 'string') {\n        data = Buffer.from(data, encoding);\n    }\n    assert(Buffer.isBuffer(data), 'data is a required String or Buffer');\n    data = hash.sha256(data);\n    return Signature.signHash(data, privateKey);\n};\n\n/**\n    Sign a buffer of exactally 32 bytes in size (sha256(text))\n\n    @arg {string|Buffer} dataSha256 - 32 byte buffer or string\n    @arg {wif|PrivateKey} privateKey\n    @arg {String} [encoding = 'hex'] - dataSha256 encoding (if string)\n\n    @return {Signature}\n*/\nSignature.signHash = function (dataSha256, privateKey) {\n    var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'hex';\n\n    if (typeof dataSha256 === 'string') {\n        dataSha256 = Buffer.from(dataSha256, encoding);\n    }\n    if (dataSha256.length !== 32 || !Buffer.isBuffer(dataSha256)) throw new Error(\"dataSha256: 32 byte buffer requred\");\n\n    privateKey = PrivateKey(privateKey);\n    assert(privateKey, 'privateKey required');\n\n    var der, e, ecsignature, i, lenR, lenS, nonce;\n    i = null;\n    nonce = 0;\n    e = BigInteger.fromBuffer(dataSha256);\n    while (true) {\n        ecsignature = ecdsa.sign(curve, dataSha256, privateKey.d, nonce++);\n        der = ecsignature.toDER();\n        lenR = der[3];\n        lenS = der[5 + lenR];\n        if (lenR === 32 && lenS === 32) {\n            i = ecdsa.calcPubKeyRecoveryParam(curve, e, ecsignature, privateKey.toPublic().Q);\n            i += 4; // compressed\n            i += 27; // compact  //  24 or 27 :( forcing odd-y 2nd key candidate)\n            break;\n        }\n        if (nonce % 10 === 0) {\n            console.log(\"WARN: \" + nonce + \" attempts to find canonical signature\");\n        }\n    }\n    return Signature(ecsignature.r, ecsignature.s, i);\n};\n\nSignature.fromBuffer = function (buf) {\n    var i, r, s;\n    assert(Buffer.isBuffer(buf), 'Buffer is required');\n    assert.equal(buf.length, 65, 'Invalid signature length');\n    i = buf.readUInt8(0);\n    assert.equal(i - 27, i - 27 & 7, 'Invalid signature parameter');\n    r = BigInteger.fromBuffer(buf.slice(1, 33));\n    s = BigInteger.fromBuffer(buf.slice(33));\n    return Signature(r, s, i);\n};\n\nSignature.fromHex = function (hex) {\n    return Signature.fromBuffer(Buffer.from(hex, \"hex\"));\n};\n\n/**\n    @arg {string} signature - like SIG_K1_base58signature..\n    @return {Signature} or `null` (invalid)\n*/\nSignature.fromString = function (signature) {\n    try {\n        return Signature.fromStringOrThrow(signature);\n    } catch (e) {\n        return null;\n    }\n};\n\n/**\n    @arg {string} signature - like SIG_K1_base58signature..\n    @throws {Error} invalid\n    @return {Signature}\n*/\nSignature.fromStringOrThrow = function (signature) {\n    assert.equal(typeof signature === 'undefined' ? 'undefined' : _typeof(signature), 'string', 'signature');\n    var match = signature.match(/^SIG_([A-Za-z0-9]+)_([A-Za-z0-9]+)$/);\n    assert(match != null && match.length === 3, 'Expecting signature like: SIG_K1_base58signature..');\n\n    var _match = _slicedToArray(match, 3),\n        keyType = _match[1],\n        keyString = _match[2];\n\n    assert.equal(keyType, 'K1', 'K1 signature expected');\n    return Signature.fromBuffer(keyUtils.checkDecode(keyString, keyType));\n};\n\n/**\n    @arg {String|Signature} o - hex string\n    @return {Signature}\n*/\nSignature.from = function (o) {\n    var signature = o ? o.r && o.s && o.i ? o : typeof o === 'string' && o.length === 130 ? Signature.fromHex(o) : typeof o === 'string' && o.length !== 130 ? Signature.fromStringOrThrow(o) : Buffer.isBuffer(o) ? Signature.fromBuffer(o) : null : o; /*null or undefined*/\n\n    if (!signature) {\n        throw new TypeError('signature should be a hex string or buffer');\n    }\n    return signature;\n};"]},"metadata":{},"sourceType":"script"}